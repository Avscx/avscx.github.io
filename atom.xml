<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>_寻鹿&#39;s Blog</title>
  
  <subtitle>野旷天低 江清月近</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-25T09:06:25.725Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Avscx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C_基础知识</title>
    <link href="http://yoursite.com/2019/04/25/C_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/04/25/C_基础知识/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-04-25T09:06:25.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API-Application-Programming-Interface-–-应用程序编程接口"><a href="#API-Application-Programming-Interface-–-应用程序编程接口" class="headerlink" title="API(Application Programming Interface) – 应用程序编程接口"></a>API(Application Programming Interface) – 应用程序编程接口</h2><blockquote><p>应用程序接口为：“计算机操作系统（Operating system）或程序库提供给应用程序调用使用的代码”。<br>其主要目的是让应用程序开发人员得以调用一组例程功能，而无须考虑其底层的源代码为何、或理解其内部工作机制的细节。<br>API本身是抽象的，它仅定义了一个接口，而不涉入应用程序如何实现的细节</p></blockquote><p>Windows 程序设计有两种方式： C语言方式（SDK）和 C++方式（对SDK函数进行包装，如VC中的MFC、BCB中的VCL）</p><h2 id="SDK-Software-Development-Kit-–-软件开发工具包"><a href="#SDK-Software-Development-Kit-–-软件开发工具包" class="headerlink" title="SDK(Software Development Kit) – 软件开发工具包"></a>SDK(Software Development Kit) – 软件开发工具包</h2><p>一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的开发工具的集合。<br>Windows SDK 编程简单的说就是使用 C 语言调用 Windows 提供的 API 函数的编程</p><h2 id="MFC-Microsoft-Foundations-Classes-–-微软基础类"><a href="#MFC-Microsoft-Foundations-Classes-–-微软基础类" class="headerlink" title="MFC(Microsoft Foundations Classes) – 微软基础类"></a>MFC(Microsoft Foundations Classes) – 微软基础类</h2><p>MFC 是一个微软公司提供的类库（class libraries），以 C++ 类的形式封装了 Windows API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。<br>其中包含的类包含大量 Windows 句柄封装类和很多 Windows 的内建控件和组件的封装类。<br>简而言之，SDK 编程就是直接利用 Windows 提供的 API 函数进行编程，而 MFC 是利用类的概念对 API 函数进行封装，结合面向对象的继承、多态组成一个个类，共有一百多个类组成</p><h2 id="为什么不推荐初学者学习-MFC？"><a href="#为什么不推荐初学者学习-MFC？" class="headerlink" title="为什么不推荐初学者学习 MFC？"></a>为什么不推荐初学者学习 MFC？</h2><p>微软千辛万苦封装了个 MFC，但很多资深程序员反而警告初学者不要去学习 MFC，这是为什么呢？<br>对于程序员来说，操作系统的功能完全是由 API 来定义。也就是说，操作系统若能够完成的事情，都会提供相应的 API 供调用。<br>因此，搞熟这些 API 对你理解 Windows 的运行机制非常有帮助。今后你无论使用什么来编写 Windows 程序，都是水到渠成。<br>API 函数本身就是进行了一层封装（例如上边我们提到的，我们根本不需要去理解如何在屏幕上显示字符串的原理），而 MFC 是再对 API 进行封装。<br>因此初学者如果直接学习 MFC 编程，就很难理解 Windows 的运行原理，而不理解原理的学习就会显得亦步亦趋。<br>反过来，如果当你首先掌握了这些 API 函数以及 Windows 的运行机制，你再来学习 MFC，学习就会变得事半功倍了！</p><h2 id="stdcall，cdecl，pascal，fastcall"><a href="#stdcall，cdecl，pascal，fastcall" class="headerlink" title="stdcall，cdecl，pascal，fastcall"></a><strong>stdcall，</strong>cdecl，<strong>pascal，</strong>fastcall</h2><h3 id="cdecl"><a href="#cdecl" class="headerlink" title="__cdecl"></a>__cdecl</h3><p>__cdecl 是 C Declaration  的缩写，表示 C 语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。<br>被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。</p><h3 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h3><p>__stdcall 是 Standard Call 的缩写，是 C++ 的标准调用方式：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是 this 指针。<br>这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 retnX，X 表示参数占用的字节数，CPU 在 ret 之后自动弹出 X 个字节的堆栈空间，称为自动清栈。函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。</p><h3 id="pascal"><a href="#pascal" class="headerlink" title="__pascal"></a>__pascal</h3><p><strong>pascal 是 Pascal 语言（Delphi）的函数调用方式，也可以在 C/C++ 中使用，参数压栈顺序与前两者相反。返回时的清栈方式与 </strong>stdcall 相同。</p><h3 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h3><p><strong>fastcall 是编译器指定的快速调用方式。由于大多数的函数参数个数很少，使用堆栈传递比较费时。<br>因此 </strong>fastcall 通常规定将前两个（或若干个）参数由寄存器传递，其余参数还是通过堆栈传递。<br>不同编译器编译的程序规定的寄存器不同，返回方式和 __stdcall 相当。</p><h3 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h3><p><strong>thiscall 是为了解决类成员调用中 this 指针传递而规定的。</strong>thiscall 要求把 this 指针放在特定寄存器中，该寄存器由编译器决定。<br>VC 使用 ecx，Borland 的 C++ 编译器使用 eax。返回方式和 __stdcall 相当。</p><p><strong>fastcall 和 </strong>thiscall 涉及的寄存器由编译器决定，因此不能用作跨编译器的接口。所以 Windows 上的 COM 对象接口都定义为 <strong>stdcall 调用方式。<br>C 语言中不加说明默认函数为 </strong>cdecl 方式（C中也只能用这种方式），C++ 也一样，但是默认的调用方式可以在 IDE 环境中设置</p><h2 id="宏定义和别名在-Windows-编程上的应用"><a href="#宏定义和别名在-Windows-编程上的应用" class="headerlink" title="宏定义和别名在 Windows 编程上的应用"></a>宏定义和别名在 Windows 编程上的应用</h2><p><a href="https://fishc.com.cn/thread-46645-1-1.html" target="_blank" rel="noopener">相关链接</a></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static 的最主要功能是隐藏，其次因为 static 变量存放在静态存储区，所以它具备持久性和默认值 0<br><a href="https://fishc.com.cn/thread-46994-1-1.html" target="_blank" rel="noopener">相关链接</a></p><h2 id="WNDCLASS-结构"><a href="#WNDCLASS-结构" class="headerlink" title="WNDCLASS 结构"></a>WNDCLASS 结构</h2><p>Windows 的窗口总是基于窗口类来创建的，窗口类同时确定了处理窗口消息的窗口过程(<strong>回调函数</strong>)<br>在创建应用程序窗口之前，必须调用 RegisterClass 函数来注册窗口类。该函数只需要一个参数，即指向 WNDCLASS 窗口类的指针。<br>因为 WNDCLASS 类包含了窗口所拥有的基本属性。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagWNDCLASSW &#123;</span><br><span class="line">    UINT        style<span class="comment">;</span></span><br><span class="line">    WNDPROC     lpfnWndProc<span class="comment">;</span></span><br><span class="line">    int         cbClsExtra<span class="comment">;</span></span><br><span class="line">    int         cbWndExtra<span class="comment">;</span></span><br><span class="line">    HINSTANCE   hInstance<span class="comment">;</span></span><br><span class="line">    HICON       hIcon<span class="comment">;</span></span><br><span class="line">    HCURSOR     hCursor<span class="comment">;</span></span><br><span class="line">    HBRUSH      hbrBackground<span class="comment">;</span></span><br><span class="line">    LPCWSTR     lpszMenuName<span class="comment">;</span></span><br><span class="line">    LPCWSTR     lpszClassName<span class="comment">;</span></span><br><span class="line">&#125; WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="成员解析"><a href="#成员解析" class="headerlink" title="成员解析"></a>成员解析</h3><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>style</td><td>指定窗口类型，各种“类风格”（详见下方↓）可以使用按位或操作符组合起来</td></tr><tr><td>lpfnWndProc</td><td>指定窗口过程（必须是<strong>回调函数</strong>）</td></tr><tr><td>cbClsExtra</td><td>预留的额外空间，一般为 0</td></tr><tr><td>cbWndExtra</td><td>预留的额外空间，一般为 0</td></tr><tr><td>hInstance</td><td>应用程序的实例句柄</td></tr><tr><td>hIcon</td><td>为所有基于该窗口类的窗口设定一个图标</td></tr><tr><td>hCursor</td><td>为所有基于该窗口类的窗口设定一个鼠标指针</td></tr><tr><td>hbrBackground</td><td>指定窗口背景色</td></tr><tr><td>lpszMenuName</td><td>指定窗口菜单</td></tr><tr><td>lpszClassName</td><td>指定窗口类名</td></tr></tbody></table><h3 id="style类风格"><a href="#style类风格" class="headerlink" title="style类风格"></a>style类风格</h3><table><thead><tr><th>类风格</th><th>含义</th></tr></thead><tbody><tr><td>CS_VREDRAW</td><td>移动或者调整窗口的高度（垂直方向）时，重绘整个窗口</td></tr><tr><td>CS_HREDRAW</td><td>移动或者调整窗口的宽度（水平方向）时，重绘整个窗口</td></tr><tr><td>CS_DBLCLKS</td><td>当用户光标在窗口内双击时，允许发送双击消息给窗口过程</td></tr><tr><td>CS_OWNDC</td><td>给予每个窗口实例分配一个唯一的 DC（注意，尽管这样是很方便，但它必须慎重使用，因为每个DC大约要占800个字节的内存）</td></tr><tr><td>CS_CLASSDC</td><td>该窗口类的所有窗口实例都共享一个窗口类 DC</td></tr><tr><td>CS_PARENTDC</td><td>1.将子窗口的裁剪区域设置到父窗口的 DC 中去，这样子窗口便可以在父窗口上绘制自身。（注意，这是子窗口从系统缓存中获取 DC，而不是使用父窗口的 DC。）</td></tr><tr><td>—</td><td>2.指定该风格可以提高系统性能</td></tr><tr><td>CS_NOCLOSE</td><td>禁止系统菜单的关闭选项</td></tr><tr><td>CS_SAVEBITS</td><td>1.以位图形式保存被该窗口遮挡的屏幕部分，当给窗口移动以后，系统便可以用该保存的位图恢复屏幕移动的相应部分，从而系统不用向被该窗口遮挡的窗口发送 WM_PAINT 消息</td></tr><tr><td>—</td><td>2.该特性对于菜单类型的窗口比较合适，因为它通常是简短的显示一下之后便消失</td></tr><tr><td>—</td><td>3.设置该特性将增加显示该窗口的时间，因为它通常要先分配保存位图的内存</td></tr><tr><td>CS_BYTEALIGNCLIENT</td><td>在字节边界上（在 x 方向上）定位窗口的用户区域的位置</td></tr><tr><td>CS_BYTEALIGNWINDOW</td><td>在字节边界上（在 x 方向上）定位窗口的位置</td></tr><tr><td>CS_GLOBALCLASS</td><td>1.当调用 CreateWindow 或 CreateWindowEx 函数来创建窗口时允许它的 hInstance 参数和注册窗口类时传递给 RegisterClass 的 hInstance 参数不同</td></tr><tr><td>—</td><td>2.如果不指定该风格，则这两个 hInstance 必须相同</td></tr></tbody></table><h2 id="大写标识符"><a href="#大写标识符" class="headerlink" title="大写标识符"></a>大写标识符</h2><p>在 Winodows 的定义中包含着许多大写标识符，这些标识符有很多都是以两个或三个字母作为前缀，且其后紧跟一个下划线：</p><p>CS_HREDRAW<br>DT_VCENTER<br>SND_FILENAME<br>CS_VREDRAW<br>IDC_ARROW<br>WM_CREATE<br>CW_USEDEFAULT<br>IDI_APPLICATION<br>WM_DESTROY<br>DT_CENTER<br>MB_ICONERROR<br>WM_PAINT<br>DT_SINGLELINE<br>SND_ASYNC<br>WS_OVERLAPPEDWINDOW</p><p>这些标识符其实都是宏定义，前缀标明该常量所属的一般类别，含义如下:</p><table><thead><tr><th>前缀</th><th>含义</th></tr></thead><tbody><tr><td>CS</td><td>类风格选项（ClassStyle）</td></tr><tr><td><strong>CW</strong></td><td>创建窗口选项（CreateWindow）</td></tr><tr><td>DT</td><td>文本绘制选项（DrawText）</td></tr><tr><td>IDI</td><td>图标的 ID 号（IDIcon）</td></tr><tr><td>IDC</td><td>光标的 ID 号（IDCursor）</td></tr><tr><td>MB</td><td>消息框选项（MessageBox）</td></tr><tr><td>SND</td><td>声音选项（Sound）</td></tr><tr><td>WM</td><td>窗口消息（WindowsMessage）</td></tr><tr><td>WS</td><td>窗口风格（WindowStyles）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;API-Application-Programming-Interface-–-应用程序编程接口&quot;&gt;&lt;a href=&quot;#API-Application-Programming-Interface-–-应用程序编程接口&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="C语言教程" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Reverse" scheme="http://yoursite.com/tags/Reverse/"/>
    
      <category term="by-fishc" scheme="http://yoursite.com/tags/by-fishc/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑_CTF-Notes</title>
    <link href="http://yoursite.com/2019/04/16/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91_CTF-Notes/"/>
    <id>http://yoursite.com/2019/04/16/西湖论剑_CTF-Notes/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-17T15:51:12.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EasyCpp"><a href="#EasyCpp" class="headerlink" title="EasyCpp"></a>EasyCpp</h2><p>1、获取输入<br>push_back: c++中的vector头文件里面就有这个push_back函数，在vector类中作用为在vector尾部加入一个数据<br><img src="/2019/04/16/西湖论剑_CTF-Notes/EasyCpp_1.png" alt="EasyCpp_1"><br>2、生成16个斐波那契数列<br><img src="/2019/04/16/西湖论剑_CTF-Notes/EasyCpp_2.png" alt="EasyCpp_2"><br>递归生成<br><img src="/2019/04/16/西湖论剑_CTF-Notes/EasyCpp_3.png" alt="EasyCpp_3"><br>3、transform<br><img src="/2019/04/16/西湖论剑_CTF-Notes/EasyCpp_4.png" alt="EasyCpp_4"><br><img src="/2019/04/16/西湖论剑_CTF-Notes/EasyCpp_5.png" alt="EasyCpp_5"><br>4、取反比较<br>std::accumulate这里可以动态调试跟进查看返回结果易知该函数作用为取反<br><img src="/2019/04/16/西湖论剑_CTF-Notes/EasyCpp_6.png" alt="EasyCpp_6"><br>5、Re</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!usr/bin/env <span class="keyword">python</span></span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="keyword">p</span> = process(<span class="string">'./easyCpp'</span>)</span><br><span class="line"></span><br><span class="line">flag = [<span class="number">987</span>]</span><br><span class="line"><span class="keyword">res</span> = [<span class="number">987</span>,<span class="number">610</span>,<span class="number">377</span>,<span class="number">233</span>,<span class="number">144</span>,<span class="number">89</span>,<span class="number">55</span>,<span class="number">34</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    flag.<span class="keyword">append</span>(<span class="keyword">res</span>[i+<span class="number">1</span>] - <span class="keyword">res</span>[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in fla<span class="variable">g:</span></span><br><span class="line">    <span class="keyword">p</span>.sendline(str(i))</span><br><span class="line"><span class="keyword">print</span> <span class="keyword">p</span>.recv()</span><br></pre></td></tr></table></figure><p><img src="/2019/04/16/西湖论剑_CTF-Notes/EasyCpp_7.png" alt="EasyCpp_7"></p><h2 id="Testre"><a href="#Testre" class="headerlink" title="Testre"></a>Testre</h2><p>1、Input<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_1.png" alt="Testre_1"><br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_2.png" alt="Testre_2"><br>2、Check<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_3.png" alt="Testre_3"><br>进入函数<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_4.png" alt="Testre_4"><br>这个函数也是混淆，没什么作用<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_5.png" alt="Testre_5"><br>由于v17为0，这里n、v23、v11为固定数值，直接动态调试可得<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_6.png" alt="Testre_6"><br>Base58编码<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_7.png" alt="Testre_7"><br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_8.png" alt="Testre_8"><br>将base58编码后数据与D9cS9N9iHjMLTdA8YSMRMp进行比较，相同则getflag<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Testre_9.png" alt="Testre_9"><br>逆向代码:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">from</span> Crypto.Util.<span class="built_in">number</span> import long_to_bytes</span><br><span class="line"></span><br><span class="line">res = <span class="string">'D9cS9N9iHjMLTdA8YSMRMp'</span></span><br><span class="line"><span class="keyword">byte</span> = <span class="string">'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'</span></span><br><span class="line">res_1 =[]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> res:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">len</span>(<span class="keyword">byte</span>)):</span><br><span class="line">        <span class="keyword">if</span> s == <span class="keyword">byte</span>[i]:</span><br><span class="line">            res_1.append(i)</span><br><span class="line"><span class="comment">#print res_1 </span></span><br><span class="line"></span><br><span class="line">res_2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res_1:</span><br><span class="line">    res_2 = res_2 * <span class="number">58</span> + i</span><br><span class="line"></span><br><span class="line">print long_to_bytes(res_2)</span><br><span class="line"><span class="comment">#flag base58_is_boring</span></span><br></pre></td></tr></table></figure><h2 id="Junk-Instruction"><a href="#Junk-Instruction" class="headerlink" title="Junk_Instruction"></a>Junk_Instruction</h2><p>1、程序由MFC编写，首先，使用XSPY定位窗口按键函数，可知check按键关键函数在偏移位0x2420处<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Junk_Instruction_1.png" alt="Junk_Instruction_1"><br>2、进入关键函数，存在条件语句，推测if语句判断后会输出成功或失败的信息<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Junk_Instruction_2.png" alt="Junk_Instruction_2"><br>3、进入偏移为0x2600函数<br>存在一段数据，可能在程序执行过程中会用到<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Junk_Instruction_3.png" alt="Junk_Instruction_3"><br>由于程序存在大量花指令，分析发现在函数内存在jump语句一般带有一段固定的汇编代码，此处即为花指令，直接nop掉固定的字节流<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Junk_Instruction_4.png" alt="Junk_Instruction_4"><br>花指令去除脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ida_bytes <span class="keyword">import</span> get_bytes, patch_bytes</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">addr = <span class="number">0x402400</span></span><br><span class="line">end = <span class="number">0x403000</span></span><br><span class="line">buf = get_bytes(addr, end-addr)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler1</span><span class="params">(s)</span>:</span></span><br><span class="line">    s = s.group(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">""</span>.join([<span class="string">"%02x"</span>%ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> s]))</span><br><span class="line">    s = <span class="string">"\x90"</span>*len(s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">p = <span class="string">r"\xe8\x00\x00\x00\x00.*?\xc3.*?\xc3\xBB\x22&#123;4&#125;"</span></span><br><span class="line">buf = re.sub(p, handler1, buf, flags=re.I)</span><br><span class="line">patch_bytes(addr, buf)</span><br><span class="line">print(<span class="string">"Done"</span>)</span><br></pre></td></tr></table></figure><p>Nop掉花指令之后，由于程序还是采用之前的堆栈，需要让IDA重新分析（U C P）<br>在偏移为0x2AF0函数中，对Input进行了长度判断和Handle<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Junk_Instruction_5.png" alt="Junk_Instruction_5"><br>一串字符，结合之后0x2CA0处函数，可知为RC4密钥<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Junk_Instruction_6.png" alt="Junk_Instruction_6"><br>在偏移为0x2CA0函数中，存在RC4算法<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Junk_Instruction_7.png" alt="Junk_Instruction_7"><br>将rc4加密后数据和一开始的那段数据进行比较<br><img src="/2019/04/16/西湖论剑_CTF-Notes/Junk_Instruction_8.png" alt="Junk_Instruction_8"><br>4、逆向代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!usr/bin/env python</span><br><span class="line">#coding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line">from Crypto<span class="selector-class">.Cipher</span> import ARC4</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">enc = <span class="string">''</span></span><br><span class="line">res = [<span class="number">0</span>x5B,<span class="number">0</span>xD6,<span class="number">0</span>xD0,<span class="number">0</span>x26,<span class="number">0</span>xC8,<span class="number">0</span>xDD,<span class="number">0</span>x19,<span class="number">0</span>x7E,<span class="number">0</span>x6E,<span class="number">0</span>x3E,<span class="number">0</span>xCB,<span class="number">0</span>x16,<span class="number">0</span>x91,<span class="number">0</span>x7D,<span class="number">0</span>xFF,<span class="number">0</span>xAF,<span class="number">0</span>xDD,<span class="number">0</span>x76,<span class="number">0</span>x64,<span class="number">0</span>xB0,<span class="number">0</span>xF7,<span class="number">0</span>xE5,<span class="number">0</span>x89,<span class="number">0</span>x57,<span class="number">0</span>x82,<span class="number">0</span>x9F,<span class="number">0</span>x0C,<span class="number">0</span>x00,<span class="number">0</span>x9E,<span class="number">0</span>xD0,<span class="number">0</span>x45,<span class="number">0</span>xFA]</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> res:</span><br><span class="line">enc += chr(i)</span><br><span class="line">passwd = <span class="string">'qwertyuiop'</span></span><br><span class="line">res_3 = ARC4.new(passwd)</span><br><span class="line"><span class="selector-tag">a</span> = res_3.decrypt(enc)</span><br><span class="line">print <span class="selector-tag">a</span>.decode(<span class="string">'utf-8'</span>)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;EasyCpp&quot;&gt;&lt;a href=&quot;#EasyCpp&quot; class=&quot;headerlink&quot; title=&quot;EasyCpp&quot;&gt;&lt;/a&gt;EasyCpp&lt;/h2&gt;&lt;p&gt;1、获取输入&lt;br&gt;push_back: c++中的vector头文件里面就有这个push_back
      
    
    </summary>
    
      <category term="Reverse" scheme="http://yoursite.com/categories/Reverse/"/>
    
    
      <category term="Reverse" scheme="http://yoursite.com/tags/Reverse/"/>
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
      <category term="ELF" scheme="http://yoursite.com/tags/ELF/"/>
    
  </entry>
  
  <entry>
    <title>API-notes</title>
    <link href="http://yoursite.com/2019/04/10/API-Notes/"/>
    <id>http://yoursite.com/2019/04/10/API-Notes/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-04-25T09:15:36.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h2><p>MessageBox 函数用于显示一个模态对话框，其中包含一个系统图标、 一组按钮和一个简短的特定于应用程序消息，如状态或错误的信息<br>消息框中返回一个整数值，该值指示用户单击了哪个按钮</p><p>API 函数原型：注释：_In_ 说明该参数是输入的，<em>opt</em> 说明该参数是可选参数</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int WINAPI MessageBox</span><br><span class="line">(</span><br><span class="line"><span class="variable">_In_opt_</span>  HWND hWnd,</span><br><span class="line"><span class="variable">_In_opt_</span>  LPCTSTR lpText,</span><br><span class="line"><span class="variable">_In_opt_</span>  LPCTSTR lpCaption,</span><br><span class="line"><span class="variable">_In_</span>      UINT uType</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>hWnd</td><td>1.该消息框的父窗口句柄</td></tr><tr><td></td><td>2.如果此参数为NULL,则该消息框没有拥有父窗口</td></tr><tr><td>lpText</td><td>1.消息框的内容</td></tr><tr><td>lpCaption</td><td>1.消息框的标题</td></tr><tr><td>uType</td><td>1.指定一个决定对话框的内容和行为的位标志集,此参数可以通过指定下列标志或标志的组合，来显示消息框中的按钮以及图标</td></tr></tbody></table><h3 id="uType参数定义解析"><a href="#uType参数定义解析" class="headerlink" title="uType参数定义解析"></a>uType参数定义解析</h3><table><thead><tr><th>按钮</th><th>含义</th></tr></thead><tbody><tr><td>MB_OK</td><td>默认值，有一个“确认”按钮在里面</td></tr><tr><td>MB_YESNO</td><td>有“是”和“否”两个按钮在里面</td></tr><tr><td>MB_ABORTRETRYIGNORE</td><td>有“中止”，“重试”和“跳过”三个按钮在里面</td></tr><tr><td>MB_YESNOCANCEL</td><td>有“是”，“否”和“取消”三个按钮在里面</td></tr><tr><td>MB_RETRYCANCEL</td><td>有“重试”和“取消”两个按钮在里面</td></tr><tr><td>MB_OKCANCEL</td><td>有“确定”和“取消”两个按钮在里面</td></tr></tbody></table><table><thead><tr><th>图标</th><th>含义</th></tr></thead><tbody><tr><td>MB_ICONEXCLAMATION</td><td>一个惊叹号出现在消息框</td></tr><tr><td>MB_ICONWARNING</td><td>一个惊叹号出现在消息框</td></tr><tr><td>MB_ICONINFORMATION</td><td>一个圆圈中小写字母i组成的图标出现在消息框</td></tr><tr><td>MB_ICONASTERISK</td><td>一个圆圈中小写字母i组成的图标出现在消息框</td></tr><tr><td>MB_ICONSTOP</td><td>一个停止消息图标出现在消息框</td></tr><tr><td>MB_ICONERROR</td><td>一个停止消息图标出现在消息框</td></tr><tr><td>MB_ICONHAND</td><td>一个停止消息图标出现在消息框</td></tr></tbody></table><table><thead><tr><th>默认按钮</th><th>含义</th></tr></thead><tbody><tr><td>MB_DEFBUTTON1</td><td>指定第一个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON2</td><td>指定第二个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON3</td><td>指定第三个按钮为默认按钮</td></tr><tr><td>MB_DEFBUTTON4</td><td>指定第四个按钮为默认按钮</td></tr></tbody></table><table><thead><tr><th>消息框形态</th><th>含义</th></tr></thead><tbody><tr><td>MB_APPLMODAL</td><td>1.在 hWnd 参数标识的窗口中继续工作以前，用户一定响应消息框</td></tr><tr><td></td><td>2.但是，用户可以移动到其他线程的窗口且在这些窗口中工作</td></tr><tr><td></td><td>3.根据应用程序中窗口的层次机构，用户则以移动到线程内的其他窗口</td></tr><tr><td></td><td>4.所有母消息框的子窗口自动地失效，但是弹出窗口不是这样</td></tr><tr><td></td><td>5.如果既没有指定 MB_SYSTEMMODAL 也没有指定 MB_TASKMODAL，则 MB_APPLMODAL 为默认的</td></tr><tr><td>MB_SYSTEMMODAL</td><td>1.除了消息框有 WB_EX_TOPMOST 类型，否则 MB_APPLMODAL 和 MB_SYSTEMMODAL 一样</td></tr><tr><td></td><td>2.用系统模态消息框来改变各种各样的用户，主要的损坏错误需要立即注意（例如，内存溢出</td></tr><tr><td></td><td>3.如果不是那些与 hWnd 联系的窗口，此标志对用户对窗口的相互联系没有影响</td></tr><tr><td>MB_TASKMODAL</td><td>1.如果参数 hWnd 为 NULL 的话，那么除了所有属于当前线程高层次的窗口失效外，MB_TASKMODAL 和 MB_APPLMODAL 一样</td></tr><tr><td></td><td>2.当调用应用程序或库没有一个可以得到的窗口句柄时，可以使用此标志，但仍需要阻止输入到调用线程的其他窗口，而不是搁置其他线程</td></tr></tbody></table><table><thead><tr><th>其他标志</th><th>含义</th></tr></thead><tbody><tr><td>MB_DEFAULT_DESKTOP_ONLY</td><td>1.接收输入的当前桌面一定是一个默认桌面，否则函数调用失败</td></tr><tr><td></td><td>2.默认桌面是一个在用户已经记录且以后应用程序在此上面运行的桌面</td></tr><tr><td>MB_HELP</td><td>1.把一个Help按钮增加到消息框</td></tr><tr><td></td><td>2.选择Help按钮或按F1产生一个Help事件</td></tr><tr><td>MB_RIGHT</td><td>1.文本为右对齐</td></tr><tr><td>MB_RTLREADING</td><td>1.用在Hebrew和Arabic系统中从右到左的顺序显示消息和大写文本</td></tr><tr><td>MB_SETFOREGROUND</td><td>1.消息框变为前景窗口</td></tr><tr><td></td><td>2.在内部系统为消息个调用SetForegroundWindow函数</td></tr><tr><td>MB_TOPMOST</td><td>1.消息框用WS_EX_TOPMOST窗口类型来创建MB_SERVICE_NOTIFICATION</td></tr></tbody></table><p>返回值:</p><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td>IDOK</td><td>用户按下了“确认”按钮</td></tr><tr><td>IDCANCEL</td><td>用户按下了“取消”按钮</td></tr><tr><td>IDABORT</td><td>用户按下了“中止”按钮</td></tr><tr><td>IDRETRY</td><td>用户按下了“重试”按钮</td></tr><tr><td>IDIGNORE</td><td>用户按下了“忽略”按钮</td></tr><tr><td>IDYES</td><td>用户按下了“是”按钮</td></tr><tr><td>IDNO</td><td>用户按下了“否”按钮</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"这是我在鱼C学的第一个程序！"</span>), TEXT(<span class="string">"打招呼"</span>), MB_OKCANCEL  MB_ICONQUESTION  MB_DEFBUTTON2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CreateWindow"><a href="#CreateWindow" class="headerlink" title="CreateWindow"></a>CreateWindow</h2><p>CreateWindow 函数创建一个重叠式窗口、弹出式窗口或子窗口。它指定窗口类，窗口标题，窗口风格，以及窗口的初始位置及大小（可选的）。<br>函数也指该窗口的父窗口或所属窗口（如果存在的话），及窗口的菜单。<br>若要使用除 CreateWindow 函数支持的风格外的扩展风格，则使用 CreateWindowEx 函数代替 CreateWindow 函数</p><p>API 函数原型：注释：_In_ 说明该参数是输入的，<em>opt</em> 说明该参数是可选参数</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND WINAPI CreateWindow(</span><br><span class="line">  <span class="variable">_In_opt_</span>  LPCTSTR lpClassName,    <span class="comment">// 窗口类名称</span></span><br><span class="line">  <span class="variable">_In_opt_</span>  LPCTSTR lpWindowName,   <span class="comment">// 窗口标题</span></span><br><span class="line">  <span class="variable">_In_</span>      DWORD dwStyle,          <span class="comment">// 窗口风格，或称窗口格式</span></span><br><span class="line">  <span class="variable">_In_</span>      int x,                  <span class="comment">// 初始 x 坐标</span></span><br><span class="line">  <span class="variable">_In_</span>      int y,                  <span class="comment">// 初始 y 坐标</span></span><br><span class="line">  <span class="variable">_In_</span>      int nWidth,             <span class="comment">// 初始 x 方向尺寸</span></span><br><span class="line">  <span class="variable">_In_</span>      int nHeight,            <span class="comment">// 初始 y 方向尺寸</span></span><br><span class="line">  <span class="variable">_In_opt_</span>  HWND hWndParent,        <span class="comment">// 父窗口句柄</span></span><br><span class="line">  <span class="variable">_In_opt_</span>  HMENU hMenu,            <span class="comment">// 窗口菜单句柄</span></span><br><span class="line">  <span class="variable">_In_opt_</span>  HINSTANCE hInstance,    <span class="comment">// 程序实例句柄</span></span><br><span class="line">  <span class="variable">_In_opt_</span>  LPVOID lpParam          <span class="comment">// 创建参数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>lpClassName</td><td>1.窗口类名称，可以是一个指向 NULL 结束的字符串或一个整型数值</td></tr><tr><td>—</td><td>2.如果是字符串，它指定了窗口的类名。这个类名可以是任何用函数RegisterClass注册的类名，或是任何预定义的控制类名</td></tr><tr><td>—</td><td>3.如是一个整型量，它是由此前调用theGlobalAddAtom函数产生的全局量。这个小于0xC000的16位数必须是lpClassName参数字的低16位，该参数的高位必须是0</td></tr><tr><td>lpWindowName</td><td>1.窗口标题，一个指向NULL结束的字符串指针</td></tr><tr><td>—</td><td>2.如果窗口风格指定了标题条，由lpWindowName指向的窗口标题将显示在标题条上</td></tr><tr><td>—</td><td>3.当使用Createwindow函数来创建控制例如按钮，选择框和静态控制时，可使用lpWindowName来指定控制文本</td></tr><tr><td>dwStyle</td><td>指定创建窗口的风格（详见下方↓）</td></tr><tr><td>x</td><td>1.指定窗口的初始水平位置（x坐标）</td></tr><tr><td>—</td><td>2.对一个层叠或弹出式窗口，x参数是屏幕坐标系的窗口的左上角的初始x坐标</td></tr><tr><td>—</td><td>3.对于子窗口，x是子窗口左上角相对父窗口客户区左上角的初始x坐标</td></tr><tr><td>—</td><td>4.如果该参数被设为CW_USEDEFAULT则系统为窗口选择缺省的左上角坐标并忽略y参数，CW_USEDEFAULT只对层叠窗口有效，如果为弹出式窗口或子窗口设定，则x和y参数被设为零。</td></tr><tr><td>y</td><td>1.指定窗口的初始垂直位置（y坐标）</td></tr><tr><td>—</td><td>2.对一个层叠或弹出式窗口，y参数是屏幕坐标系的窗口的左上角的初始y坐标</td></tr><tr><td>—</td><td>3.对于子窗口，y是子窗口左上角相对父窗口客户区左上角的初始y坐标</td></tr><tr><td>—</td><td>4.对于列表框，y是列表框客户区左上角相对父窗口客户区左上角的初始y坐标</td></tr><tr><td>—</td><td>5.如果层叠窗口是使用WS_VISIBLE风格位创建的并且x参数被设为CW_USEDEFAULT，则系统将忽略y参数</td></tr><tr><td>nWidth</td><td>1.以设备单元指明窗口的宽度</td></tr><tr><td>—</td><td>2.对于层叠窗口，nWidth的值或是屏幕坐标的窗口宽度或是CW_USEDEFAULT</td></tr><tr><td>—</td><td>3.若nWidth是CW_USEDEFAULT，则系统为窗口选择一个默认的高度和宽度（默认宽度为从初始x坐标开始到屏幕的右边界，缺省高度为从初始y坐标开始到目标区域的顶部。)，CW_USEDEFAULT只对层叠窗口有效，如果为弹出式窗口和子窗口设定CW_USEDEFAULT标志则nWidth和nHeight被设为零</td></tr><tr><td>nHeight</td><td>1.以设备单元指明窗口的高度</td></tr><tr><td>—</td><td>2.对于层叠窗口，nHeight是屏幕坐标的窗口宽度</td></tr><tr><td>—</td><td>3.若nWidth被设为CW_USEDEFAULT，则系统忽略nHeight参数，自动为nWidth和nHeight设置默认参数</td></tr><tr><td>hWndParent</td><td>1.指向被创建窗口的父窗口或所有者窗口的句柄</td></tr><tr><td>—</td><td>2.若要创建一个子窗口或一个从属窗口，需提供一个有效的窗口句柄</td></tr><tr><td>—</td><td>3.创建一个单纯的消息窗口，可以提供HWND_MESSAGE或提供一个己存在的消息窗口的句柄</td></tr><tr><td>hMenu</td><td>1.指向窗口菜单句柄，或依据窗口风格指明一个子窗口标识</td></tr><tr><td>—</td><td>2.对于层叠或弹出式窗口，hMenu指定窗口使用的菜单：如果使用了菜单类，则hMenu可以为NULL</td></tr><tr><td>—</td><td>3.对于子窗口，hMenu指定了该子窗口标识（一个整型量），一个对话框使用这个整型值将事件通知父类。应用程序确定子窗口标识，这个值对于相同父窗口的所有子窗口必须是唯一的</td></tr><tr><td>hInstance</td><td>与窗口相关联的模块实例的句柄</td></tr><tr><td>lpParam</td><td>1.指向一个值的指针，该值传递给窗口WM_CREATE消息。该值通过在IParam参数中的CREATESTRUCT结构传递</td></tr><tr><td>—</td><td>2.如果应用程序调用CreateWindow创建一个MDI客户窗口，则lpParam必须指向一个CLIENTCREATESTRUCT结构</td></tr></tbody></table><h3 id="DwStyle窗口风格解析"><a href="#DwStyle窗口风格解析" class="headerlink" title="DwStyle窗口风格解析"></a>DwStyle窗口风格解析</h3><table><thead><tr><th>窗口风格</th><th>含义</th></tr></thead><tbody><tr><td>WS_BORDER</td><td>创建一个带边框的窗口</td></tr><tr><td>WS_CAPTION</td><td>创建一个有标题框的窗口（包含了 WS_BODER 风格）</td></tr><tr><td>WS_CHILD</td><td>创建一个子窗口，这个风格的窗口不能拥有菜单也不能与 WS_POPUP 风格合用</td></tr><tr><td>WS_CHILDWINDOW</td><td>与 WS_CHILD 相同</td></tr><tr><td>WS_CLIPCHILDREN</td><td>当在父窗口内绘图时，排除子窗口区域，在创建父窗口时使用这个风格</td></tr><tr><td>WS_CLIPSIBLINGS</td><td>1.排除子窗口之间的相对区域，也就是，当一个特定的窗口接收到 WM_PAINT 消息时，WS_CLIPSIBLINGS 风格将所有层叠窗口排除在绘图之外，只重绘指定的子窗口</td></tr><tr><td>—</td><td>2.如果未指定该风格，并且子窗口是层叠的，则在重绘子窗口的客户区时，就会重绘邻近的子窗口</td></tr><tr><td>WS_DISABLED</td><td>1.创建一个初始状态为禁止的子窗口，一个禁止状态的窗口不能接受来自用户的输入信息</td></tr><tr><td>—</td><td>2.在窗口创建之后，可以调用 EnableWindow 函数来启用该窗口</td></tr><tr><td>WS_DLGFRAME</td><td>创建一个带对话框边框风格的窗口，这种风格的窗口不能带标题条</td></tr><tr><td>WS_GROUP</td><td>1.指定一组“控制窗口”的第一个“控制窗口”</td></tr><tr><td>—</td><td>2.这个“控制窗口”组由第一个“控制窗口”和随后定义的“控制窗口”组成，自第二个“控制窗口”开始每个“控制窗口”具有 WS_GROUP 风格</td></tr><tr><td>—</td><td>3.每个组的第一个“控制窗口”带有 WS_TABSTOP 风格，从而使用户可以在组间移动</td></tr><tr><td>—</td><td>4.用户随后可以使用光标在组内的控制间改变键盘焦点</td></tr><tr><td>WS_HSCROLL</td><td>创建一个有水平滚动条的窗口</td></tr><tr><td>WS_ICONIC</td><td>创建一个初始状态为最小化状态的窗口，与 WS_MINIMIZE 风格相同</td></tr><tr><td>WS_MAXIMIZE</td><td>创建一个初始状态为最大化状态的窗口</td></tr><tr><td>WS_MAXIMIZEBOX</td><td>创建一个具有最大化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td></tr><tr><td>WS_MINIMIZE</td><td>创建一个初始状态为最小化状态的窗口，与 WS_ICONIC 风格相同</td></tr><tr><td>WS_MINIMIZEBOX</td><td>创建一个具有最小化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td></tr><tr><td>WS_OVERLAPPED</td><td>产生一个层叠的窗口，一个层叠的窗口有一个标题条和一个边框，与 WS_TILED 风格相同</td></tr><tr><td>WS_OVERLAPPEDWINDOW</td><td>相当于（WS_OVERLAPPED、WS_CAPTION、WS_SYSMENU、WS_THICKFRAME、WS_MINIMIZEBOX、WS_MAXIMIZEBOX），与WS_TILEDWINDOW风格相同</td></tr><tr><td>WS_POPUP</td><td>创建一个弹出式窗口，该风格不能与WS_CHILD风格同时使用。</td></tr><tr><td>WS_POPUPWINDOW</td><td>相当于（WS_POPUP、WS_BORDER、WS_SYSMENU），但WS_CAPTION和WS_POPUPWINDOW必须同时设定才能使窗口某单可见</td></tr><tr><td>WS_SIZEBOX</td><td>创建一个可调边框的窗口，与WS_THICKFRAME风格相同</td></tr><tr><td>WS_SYSMENU</td><td>创建一个在标题条上带有窗口菜单的窗口，必须同时设定WS_CAPTION风格</td></tr><tr><td>WS_TABSTOP</td><td>1.创建一个“控制窗口”，在用户按下Tab键时可以获得键盘焦点。</td></tr><tr><td>—</td><td>2.按下Tab键后使键盘焦点转移到下一具有WS_TABSTOP风格的“控制窗口”</td></tr><tr><td>WS_THICKFRAME</td><td>创建一个具有可调边框的窗口，与WS_SIZEBOX风格相同</td></tr><tr><td>WS_TILED</td><td>产生一个层叠的窗口，一个层叠的窗口有一个标题和一个边框，与WS_OVERLAPPED风格相同</td></tr><tr><td>WS_TILEDWINDOW</td><td>相当于（WS_OVERLAPPED、WS_CAPTION、WS_SYSMENU、WS_THICKFRAME、WS_MINIMIZEBOX、WS_MAXIMIZEBOX），与WS_OVERLAPPEDWINDOW风格相同</td></tr><tr><td>WS_VISIBLE</td><td>创建一个初始状态为可见的窗口</td></tr><tr><td>WS_VSCROLL</td><td>创建一个有垂直滚动条的窗口</td></tr></tbody></table><p>返回值:<br>1.如果函数成功，返回值为新窗口的句柄；<br>2.如果函数失败，返回值为 NULL。</p><h2 id="ShowWindow"><a href="#ShowWindow" class="headerlink" title="ShowWindow"></a>ShowWindow</h2><p>ShowWindow 函数用于设置窗口的显示状态<br>应用程序第一次调用 ShowWindow 时，应该使用 WinMain 函数的 nCmdshow 参数作为它的 nCmdShow 参数。<br>在随后调用 ShowWindow 函数时，必须使用下列显示方式中的一个给定值，而不是由 WinMain 函数的 nCmdSHow 参数指定的值。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI ShowWindow(</span><br><span class="line">  _In_  <span class="built_in">HWND</span> <span class="built_in">hWnd</span>,</span><br><span class="line">  _In_  <span class="built_in">int</span> nCmdShow</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>hWnd</td><td>窗口句柄</td></tr><tr><td>nCmdShow</td><td>控制窗口如何显示，如果发送应用程序的程序提供了 STARTUPINFO 结构，则应用程序第一次调用 ShowWindow 时该参数被忽略。否则，在第一次调用 ShowWindow 函数时，该值应为在函数 WinMain 中 nCmdShow 参数</td></tr></tbody></table><p>在随后的调用中，nCmdShow 参数可以为下列值之一</p><table><thead><tr><th>显示方式</th><th>含义</th></tr></thead><tbody><tr><td>SW_FORCEMINIMIZE</td><td>1. 最小化窗口，即使拥有窗口的线程被挂起也会最小化</td></tr><tr><td>—</td><td>2.在从其他线程最小化窗口时才使用这个参数</td></tr><tr><td>SW_HIDE</td><td>隐藏窗口并激活其他窗口</td></tr><tr><td>SW_MAXIMIZE</td><td>最大化指定的窗口</td></tr><tr><td>SW_MINIMIZE</td><td>最小化指定的窗口并且激活在 Z 序中的下一个顶层窗口</td></tr><tr><td>SW_RESTORE</td><td>1.激活并显示窗口</td></tr><tr><td>—</td><td>2.如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置</td></tr><tr><td>—</td><td>3.在恢复最小化窗口时，应用程序应该指定这个标志。</td></tr><tr><td>SW_SHOW</td><td>在窗口原来的位置以原来的尺寸激活并显示窗口</td></tr><tr><td>SW_SHOWDEFAULT</td><td>依据在 STARTUPINFO 结构中指定的 SW_FLAG 标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给 CreateProcess 函数的。</td></tr><tr><td>SW_SHOWMAXIMIZED</td><td>激活窗口并将其最大化</td></tr><tr><td>SW_SHOWMINIMIZED</td><td>激活窗口并将其最小化</td></tr><tr><td>SW_SHOWMINNOACTIVE</td><td>1.窗口最小化</td></tr><tr><td>—</td><td>2.在窗口激活的情况下，这个值跟 SW_SHOWMINIMIZED 很相似</td></tr><tr><td>SW_SHOWNA</td><td>1.以窗口原来的位置以原来的尺寸显示窗口</td></tr><tr><td>—</td><td>2.在窗口激活的情况下，这个值跟 SW_SHOW 很相似</td></tr><tr><td>SW_SHOWNOACTIVATE</td><td>1.以窗口最近一次的位置和尺寸显示窗口</td></tr><tr><td>—</td><td>2.在窗口激活的情况下，这个值跟 SW_SHOWNORMAL 很相似</td></tr><tr><td>SW_SHOWNORMAL</td><td>1.激活并显示一个窗口</td></tr><tr><td>—</td><td>2.如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小</td></tr><tr><td>—</td><td>3.应用程序在第一次显示窗口的时候应该指定此标志</td></tr></tbody></table><p>返回值:<br>1.如果窗口之前可见，则返回值为非 0<br>2.如果窗口之前被隐藏，则返回值为 0</p><h2 id="UpdateWindow"><a href="#UpdateWindow" class="headerlink" title="UpdateWindow"></a>UpdateWindow</h2><p>UpdateWindow 函数绕过应用程序的消息队列，直接发送 WM_PAINT 消息给指定窗口的窗口过程。<br>如果窗口更新的区域不为空，UpdateWindow 函数通过发送一个 WM_PAINT 消息来更新指定窗口的客户区。如果更新区域为空，则不发送消息。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL UpdateWindow(</span><br><span class="line">  _In_  <span class="built_in">HWND</span> <span class="built_in">hWnd</span></span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>hWnd</td><td>指定要更新的窗口的句柄</td></tr></tbody></table><p>返回值:<br>1.如果函数调用成功，返回值为非 0<br>2.如果函数调用不成功，返回值为 0</p><h2 id="MSG-结构"><a href="#MSG-结构" class="headerlink" title="MSG 结构"></a>MSG 结构</h2><p>在 Windows 程序中，消息是由 MSG 结构体来表示的</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagMSG &#123;</span><br><span class="line">  <span class="type">HWND</span>   hwnd;</span><br><span class="line">  <span class="type">UINT</span>   message;</span><br><span class="line">  <span class="type">WPARAM</span> wParam;</span><br><span class="line">  <span class="type">LPARAM</span> lParam;</span><br><span class="line">  <span class="type">DWORD</span>  time;</span><br><span class="line">  <span class="type">POINT</span>  pt;</span><br><span class="line">&#125; <span class="type">MSG</span>, *<span class="type">PMSG</span>, *<span class="type">LPMSG</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>成员</th><th>含义</th></tr></thead><tbody><tr><td>hwnd</td><td>指定接收消息的窗口句柄,如果是线程消息，该值是 NULL</td></tr><tr><td>message</td><td>1.消息的标识符，由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏的形式</td></tr><tr><td>—</td><td>2.应用程序消息只能使用低 16 位，高 16 位被系统保留</td></tr><tr><td>—</td><td>3.传送门：Windows 常用消息及含义</td></tr><tr><td>wParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>lParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>time</td><td>该消息被投放到消息队列的时间</td></tr><tr><td>pt</td><td>当消息被投放到消息队列的时，鼠标位于屏幕中的位置</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MessageBox&quot;&gt;&lt;a href=&quot;#MessageBox&quot; class=&quot;headerlink&quot; title=&quot;MessageBox&quot;&gt;&lt;/a&gt;MessageBox&lt;/h2&gt;&lt;p&gt;MessageBox 函数用于显示一个模态对话框，其中包含一个系统图标、 一
      
    
    </summary>
    
      <category term="API教程" scheme="http://yoursite.com/categories/API%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Reverse" scheme="http://yoursite.com/tags/Reverse/"/>
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Git使用</title>
    <link href="http://yoursite.com/2019/04/08/Git/"/>
    <id>http://yoursite.com/2019/04/08/Git/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-08T17:02:58.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各系统平台安装git"><a href="#各系统平台安装git" class="headerlink" title="各系统平台安装git"></a>各系统平台安装git</h2><pre><code>linux：使用命令:sudo apt-get install git分支：（debian、unbuntu linux):sudo apt-get git-coreMax os:通过homebrew安装git，[教程]http://brew.sh/通过xcode-preferences-downloads-command Line tools安装Windows:      1.下载mysysgit      2.设置身份：(git Bash)      3.git config --global user.name &quot;your name“      4.git config --global user.email &quot;your email address&quot; </code></pre><h2 id="创建版本库（本机）"><a href="#创建版本库（本机）" class="headerlink" title="创建版本库（本机）"></a>创建版本库（本机）</h2><pre><code>选择一个地方，创建一个空目录1.mkdir 目录name2.cd    目录name3.pwd   显示当前目录（git Bash 窗口上方也有显示当前目录）初始化仓库(变为可管理):git init添加一个文本文件：（windows下由于编码问题不能用自带笔记本编辑，可使用Notepad ++) 提交到暂存区:git add 文件名字提交到版本库（只能跟踪文本文件如txt的改动，Microsofe的word由于使用二进制编辑不能跟踪改动）:git commit -m &quot;备注”</code></pre><h2 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h2><pre><code>查看仓库当前状态:git status查看当前修改与上一次修改的difference：git diff查看历史记录：git log 查看历史记录（简化）：git log --pretty=online回退：git reset --hard commit_id （最近也可用HEAD、HEAD^、HEAD~number）查看历史命令：git reflog 搭配回退有神奇的效果丢弃工作区修改：git checkout --file撤回暂存区修改：git reset HEAD file（由于暂存区会整合最新add的修改，因此不用考虑到commit_id）（从暂存区撤回的文件会被重新调回工作区）从版本库中删除文件：git rm file从版本库恢复文件：git checkout --file（等价于撤销工作区修改）（工作区最新修改会消失）  注意点:只有添加（git add）到暂存区的文件才能提交（git commit）到版本库</code></pre><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><pre><code>创建SSH KEY（可在用户主目录下查看有无.ssh目录（包含id_rsa（私钥）\id_rsa.pub（公钥）))若无,在git Bash输入命令：ssh-keygen -t rsa -C “邮件地址”最后将ssh key中的id_rsa.pub添加到github上的ssh keys中，便可向github推送文件（公开）注意：每台电脑的ssh key不同关联远程仓库：git remote add origin git@github.com:github名称/仓库名称（.git)向远程仓库推送本地分支所有内容：git push -u origin master 推送最新修改：git push origin master克隆一个远程仓库：git clone git@github.com:github名称/仓库名称(远程仓库）</code></pre><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><pre><code>创建分支 git branch 分支名称     切换分支 git checkout 分支名称创建并切换分支 git checkout -b 分支名称git merge命令用于合并指定分支到当前分支删除分支 git branch -d &lt;name&gt;用git log --graph命令可以看到分支合并图合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash然后去修复bug，修复后，再git stash pop，回到工作现场恢复有两种办法，一种是用git stash apply进行恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了     可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除多人协作的工作模式：查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突注意：1.首先，可以试图用git push origin branch-name推送自己的修改；2.如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；3.如果合并有冲突，则解决冲突，并在本地提交；4.没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><pre><code>命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签；命令git tag可以查看所有标签。</code></pre><h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><pre><code>关联远程库 git remote add &lt;name&gt; &lt;address&gt;</code></pre><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><pre><code>缩写命令名称 eg:git config --global alias.st status或者修改.gitconfig文件[alias]co = checkoutst = status</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;各系统平台安装git&quot;&gt;&lt;a href=&quot;#各系统平台安装git&quot; class=&quot;headerlink&quot; title=&quot;各系统平台安装git&quot;&gt;&lt;/a&gt;各系统平台安装git&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;linux：
使用命令:
sudo apt-get inst
      
    
    </summary>
    
      <category term="Git教程" scheme="http://yoursite.com/categories/Git%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
